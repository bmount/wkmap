<!DOCTYPE html>

<meta charset="utf-8">
<style>

body {
  margin: 0;
}

.map {
  position: relative;
  overflow: hidden;
}

.layer {
  position: absolute;
}

.tile {
  position: absolute;
  width: 256px;
  height: 256px;
}

</style>
<body>
<script src="d3.v3.min.js"></script>
<script src="tile.js"></script>
<script src="three.min.js"></script>
<script src="three.min.js"></script>
<!--
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://raw.github.com/d3/d3-plugins/master/geo/tile/tile.js"></script>
-->
<script src="osmstyle.js"></script>
<script src="ukbdraw.js"></script>
<script>

var TMS_URL = '/_canvasback/tms'


var width = window.innerWidth,
    height = window.innerHeight,
    prefix = prefixMatch(["webkit", "ms", "Moz", "O"]);

var tile = d3.geo.tile()
    .size([width, height]);

var zoom = d3.behavior.zoom()
    .scale(2 << 11)
    //.scaleExtent([2 << 8, Math.pow(2,32)])
    .translate([width / 2, height / 2])
    .on("zoom", zoomed);

var map = d3.select("body").append("div")
    .attr("class", "map")
    .style("width", width + "px")
    .style("height", height + "px")
    .call(zoom);

var layer = map.append("div")
    .attr("class", "layer");

zoomed();


function load(tile, canvas) {
  var uri = TMS_URL + '/' + tile[2] + '/' + tile[0] + '/' + tile[1] + '.ukb'
    , buf = new XMLHttpRequest;
  buf.open("GET", uri, true);
  buf.responseType = 'arraybuffer'
  buf.onreadystatechange = function () {
    if (buf.readyState === 4) {
      if (buf.status === 200) {
        if (buf.response === null) {
          return;
        } else {
          uncollect(buf.response, canvas);
          //console.log(buf.response.byteLength);
          //d3.select(canvas).attr("class", "tile")
        }
      }
    }
  }
  buf.onerror = function (err) { console.log(err); };
  buf.send(null)
  return buf
}

function zoomed() {
  var tiles = tile
      .scale(zoom.scale())
      .translate(zoom.translate())
      ();

  var image = layer
      .style(prefix + "transform", matrix3d(tiles.scale, tiles.translate))
    .selectAll(".tile")
      .data(tiles, function(d) { return d; });

  image.exit()
    .remove()
  /*.filter(function (rmed) {
        if (rmed) {
          var idarr = rmed.toString()
            if (sq[idarr]) sq[idarr].abort()
        }
      })
  */

  image.enter().append("canvas")
      .attr("class", "tile")
      .attr("height", "256px")
      .attr("width", "256px")
      .attr("id", function(d) {
          load(d, this);
          return d;
      })
      .style("left", function(d) { return (d[0] * 256) + "px"; })
      .style("top", function(d) { return (d[1] * 256) + "px"; });
      //.style("left", function(d) { return (d[0] << 8) + "px"; })
      //.style("top", function(d) { return (d[1] << 8) + "px"; });
}

function matrix3d(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1 ] + ")";
}

function prefixMatch(p) {
  var i = -1, n = p.length, s = document.body.style;
  while (++i < n) if (p[i] + "Transform" in s) return "-" + p[i].toLowerCase() + "-";
  return "";
}

function v(x,y,z){ 
  return new THREE.Vector3(x,y,z); 
}

function v2d(x,y,z) {
  return new THREE.Vector2(x,y);
}

var container3d = d3.select("body").append("div").attr("id", "container3d")

var camera, scene, renderer;
var geometry, material, mesh;

camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 100000 );
camera.position.z = 40000;

scene = new THREE.Scene();
var light = new THREE.PointLight(0xffffff);
light.position.set(50000,50000,3500000);
scene.add(light);
//material = new THREE.MeshLambertMaterial( { color: 0xff0000, wireframe: true } );

meshes = []
renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth, window.innerHeight );

container3d.appendChild( renderer.domElement );


renderer.render( scene, camera );


/*
window.setInterval( function  () {
  var cycleRandom = 0.005*Math.random();
  meshes.forEach(function (mesh) {
    mesh.rotation.x += cycleRandom;
    mesh.rotation.y += cycleRandom;
    mesh.rotation.z += cycleRandom;
})
renderer.render( scene, camera );
}, 10);
*/



var extrusionSettings = {
  size: 30, height: 0, curveSegments: 3,
  bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
  material: 0, extrudeMaterial: 1
};

var bldgGeoms = ['parcelpartial.json']
var offset0 = false;
var translate0 = false;
var pos0 = false;


function loadPolygonFeatureCollection (jsonData) {
d3.json(jsonData, function (footprints) {
  var footprints = footprints.features
  proj = d3.geo.mercator().scale(1000000000);
  var cminx = footprints[0].geometry.coordinates[0][0][0]
    , cminy = footprints[0].geometry.coordinates[0][0][1]
    ;
  var x0 = d3.min(footprints)
  if (!offset0) { 
    offset = proj([cminx, cminy]);
    offset0 = offset; //initted
  }
  //offset = proj([cminx, cminy]);
  //proj.translate(offset);
  proj.translate(offset.map(Math.abs));
  var lmatl = new THREE.MeshLambertMaterial({color: 0x111111})
  var floorGeom;
  footprints.forEach(function (e0, i0, c0) {
    floorGeom = [] // new THREE.Shape()
    e0.geometry.coordinates[0].forEach(function (e1, i1, c1) {
      floorGeom.push(
        v2d.apply(null, proj(e1).concat(0))
      )
      //floorGeom.vertices.push(
      //  v.apply(null, proj(e1).concat(100))
      //)
    })

  var footprintshape2d = new THREE.Shape(floorGeom)
  var footprintExtrudable = new THREE.ExtrudeGeometry(footprintshape2d, {
              amount: e0.properties.height*10, height: 0, curveSegments: 3,
              bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
              material: 0, extrudeMaterial: 1
            })
  var frontMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: false } );
	var sideMaterial = new THREE.MeshLambertMaterial( { color: 0xb86b00, wireframe: false } );
  var materialArray = [ frontMaterial, sideMaterial ];
	footprintExtrudable.materials = materialArray;
  isla = new THREE.Mesh( footprintExtrudable, new THREE.MeshFaceMaterial() );
  isla.rotation.x = -Math.PI/2*.82;
  scene.add(isla);
  meshes.push(isla)
  renderer.render( scene, camera );
  })
  if (!pos0) {
    camera.position.x += 5000
    pos0 = true;
  }
  renderer.render( scene, camera );
})
if (bldgGeoms.length > 0) window.setTimeout( loadPolygonFeatureCollection, 1000, bldgGeoms.pop() )
}

for (var i = 2; i < 11; i++) {
  bldgGeoms.push('partialparcelQ.json'.replace('Q', i.toString()))
}

loadPolygonFeatureCollection(bldgGeoms.pop());

function onDocumentKeyDown(event){
	var delta = 150;
	event = event || window.event;
	var keycode = event.keyCode;
	switch(keycode){
		case 37 : //left arrow
			event.preventDefault();
			camera.position.x = camera.position.x - delta;
			break;
		case 38 : // up arrow
			event.preventDefault();
			camera.position.z = camera.position.z - delta;
			break;
		case 39 : // right arrow
			event.preventDefault();
			camera.position.x = camera.position.x + delta;
			break;
		case 40 : //down arrow
			event.preventDefault();
			camera.position.z = camera.position.z + delta;
			break;
		case 190 : //
			event.preventDefault();
			camera.position.y = camera.position.y + delta;
			break;
		case 188 : //
			event.preventDefault();
			camera.position.y = camera.position.y - delta;
			break;
		case 89 : //
			event.preventDefault();
			camera.rotation.y = camera.rotation.y + Math.PI/100;
			break;
		case 88 : //
			event.preventDefault();
			camera.rotation.x = camera.rotation.x + Math.PI/100;
			break;
		case 90 : //
			event.preventDefault();
			camera.rotation.z = camera.rotation.z + Math.PI/100;
			break;
		case 55 : //
			event.preventDefault();
			camera.rotation.y = camera.rotation.y - Math.PI/100;
			break;
		case 68 : //
			event.preventDefault();
			camera.rotation.x = camera.rotation.x - Math.PI/100;
			break;
		case 83 : //
			event.preventDefault();
			camera.rotation.z = camera.rotation.z - Math.PI/100;
			break;
	}
	camera.updateProjectionMatrix();
  renderer.render( scene, camera );
}

document.addEventListener('keydown',onDocumentKeyDown,false);




</script>

